## Назначение документа

Этот документ фиксирует продуктовые требования: User Story с критериями приёмки, Use Case по функциональным областям, описание архитектурных компонентов и модулей системы, декомпозицию на эпики и дорожную карту работ.

## Обзор системы

Система состоит из микросервисов и инфраструктурных компонентов:
- HTTP Service: универсальный FastAPI‑сервис для приёма событий/запросов, аудита и интеграций. БД: `request_log` (c `created_at`), `request_audit`, `proxy_audit`.
- TG Bot Service: сервис Telegram‑бота (aiogram). Хранит профиль пользователя, входящие/исходящие сообщения, настройки приветствия, интенты. Меню команд `/start`, `/about`, `/cost`. БД: `user_state`, `bot_settings(ai_system_prompt)`, `user_profile`, `incoming_message`, `outgoing_message`, `intent`.
- AI Service: генерация ответов через локальную LLM (Ollama; модель по умолчанию `mistral`). Поддерживает системный промпт (`system`) и сохраняет историю ролей `system/user/assistant`. БД: `ai_session`, `ai_message`.
- Инфраструктура: PostgreSQL, PgAdmin, ngrok (туннель), Ollama, а также стек наблюдаемости Loki + Promtail + Grafana (дашборд провижинится автоматически).
- Внешняя админка: `adm_web` (Yii2/PHP) как отдельный контейнер, подключается к `adm_pg`.

Ключевые принципы:
- Доменные данные каналов (Telegram и др.) хранятся в соответствующих сервисах каналов, а не в HTTP Service.
- HTTP Service универсален и не зависит от конкретного источника/приёмника событий.
- Идём к наблюдаемости: подробный аудит запросов, метрики длительности, заголовки, тела ответов при ошибках.

## Эпики

1. Базовая платформа HTTP‑сервиса и аудит запросов
2. Интеграция Telegram‑бота (приветствие, первый контакт, журналирование, интенты, меню)
3. Интеграция AI‑ответов через Ollama (системный промпт)
4. Наблюдаемость, логирование и трассировка (Grafana/Loki)
5. Инфраструктура и DevEx (Docker, Makefile, PgAdmin, ngrok)
6. Безопасность и конфигурация (секреты, лимиты, таймауты)
7. Тестирование и качество (юнит/интеграционные тесты, фикстуры БД)

## User Story и критерии приёмки

### Эпик 1: HTTP‑сервис и аудит

- User Story: Как разработчик интеграций, я хочу иметь эндпоинт здоровья, чтобы система могла мониториться.
  - Критерии приёмки:
    - Запрос `GET /ping` возвращает 200 и JSON `{"status":"ok"}`.
    - Эндпоинт стабилен под нагрузкой, время ответа < 50 мс в локальной среде.

- User Story: Как аналитик, я хочу фиксировать компактный лог каждого HTTP‑запроса, чтобы видеть базовые метрики.
  - Критерии приёмки:
    - В таблице `request_log` записываются `method`, `path`, `status`, `created_at`.
    - Создан индекс `idx_request_log_created_at`.

- User Story: Как инженер поддержки, я хочу подробный аудит запросов с заголовками и телами, чтобы разбирать инциденты.
  - Критерии приёмки:
    - В `request_audit` сохраняются `method`, `path`, `query`, `body`, `status`, `request_headers_json`, `response_body`, `duration_ms`, `request_log_id`.
    - Созданы индексы `idx_request_audit_created_at`, `idx_request_audit_request_log_id`.

- User Story (задел): Как интегратор, я хочу иметь безопасный прокси‑эндпоинт, который фиксирует аудит ответов внешних API.
  - Критерии приёмки:
    - При успешном вызове фиксируется запись в `proxy_audit` с `target_url`, `status`, `response_headers_json`, `response_body_json`, `duration_ms`.
    - Ошибки 4xx/5xx логируются и возвращаются вызывающему. (Планируется)

### Эпик 2: Telegram‑бот

- User Story: Как пользователь бота, я хочу получить приветствие при первом взаимодействии, чтобы понять контекст бота.
  - Критерии приёмки:
    - При `/start` бот отправляет текст из `bot_settings.greeting_text` и сохраняет факт приветствия в `user_state.greeted_at`.
    - Повторный `/start` не дублирует приветствие, если логика это запрещает (конфигурируемо).

- User Story: Как пользователь, я хочу, чтобы первое обычное сообщение после старта также сопровождалось приветствием, если ранее ещё не было отправлено.
  - Критерии приёмки:
    - При первом сообщении без `/start` бот отправляет приветствие и помечает пользователя как greeted.
    - Приветствие сохраняется в `outgoing_message`.

- User Story: Как владелец бота, я хочу хранить профиль пользователя и входящие/исходящие сообщения, чтобы анализировать взаимодействия.
  - Критерии приёмки:
    - `user_profile` обновляется при каждом сообщении (username/имя/фамилия, `updated_at`).
    - В `incoming_message` сохраняются `chat_id`, `user_id`, `text`, `date_ts`, `raw_json`.
    - В `outgoing_message` сохраняются ответы бота.

- User Story: Как владелец бота, я хочу детерминированные ответы на часто задаваемые вопросы (FAQ) без вызова ИИ.
  - Критерии приёмки:
    - Таблица `intent`: поля `match_type` (substring|equals|startswith|regex), `pattern`, `answer_text`, `priority`, `enabled`.
    - Перед вызовом ИИ бот ищет подходящий интент (по убыванию `priority`). Если найден — отвечает текстом из БД и сохраняет исходящее.

- User Story: Как пользователь, я хочу видеть меню команд у бота, чтобы быстро ориентироваться.
  - Критерии приёмки:
    - В Telegram отображается меню `/start`, `/about`, `/cost`.
    - `/about` и `/cost` отвечают через интенты.

- User Story: Как архитектор, я хочу, чтобы HTTP‑сервис был универсальным и не хранил доменные данные Telegram.
  - Критерии приёмки:
    - В БД HTTP‑сервиса отсутствуют таблицы `tg_*`.
    - События из бота отправляются в HTTP‑сервис на `/tg/messages`, но доменные данные хранятся в базе бота.

### Эпик 3: AI‑сервис

- User Story: Как пользователь бота, я хочу получать AI‑ответ на мои сообщения, чтобы продолжать диалог.
  - Критерии приёмки:
    - По тексту сообщения бот вызывает AI‑сервис `POST /generate`.
    - Ответ сохраняется в `ai_message` (роль `assistant`).
    - При недоступности AI — мягкое поведение: бот может промолчать, не ломая UX.

- User Story: Как аналитик, я хочу видеть сессию диалога, чтобы отслеживать контекст общения.
  - Критерии приёмки:
    - `ai_session` линкуется по `chat_id` и `user_id`.
    - Каждое сообщение (`user`/`assistant`) привязано к `session_id`.

- User Story: Как продакт, я хочу управлять персоной/контекстом модели, чтобы ответы соответствовали проекту.
  - Критерии приёмки:
    - AI‑сервис принимает поле `system` и пробрасывает его в Ollama.
    - Бот берёт системный промпт из `bot_settings.ai_system_prompt` и передаёт в AI‑сервис при отсутствии срабатывания интента.

### Эпик 4: Наблюдаемость и логирование

- User Story: Как SRE, я хочу структурированные логи, чтобы разбирать инциденты.
  - Критерии приёмки:
    - Логи в JSON/ключ‑значение (structlog), включают `request_id`, длительность, статус.
    - Корреляция между `request_log` и `request_audit` через `request_log_id`.

- User Story: Как инженер сопровождения, я хочу предварительно настроенные дашборды и быстрые фильтры в Grafana.
  - Критерии приёмки:
    - Автопровижин дашборда “Monorepo Logs Overview” (панели: ошибки, активность бота/AI, сетевые проблемы TG, ошибки Ollama).
    - В Explore доступны готовые Loki‑запросы из README.

### Эпик 5: Инфраструктура и DevEx

- User Story: Как разработчик, я хочу поднять все компоненты одной командой.
  - Критерии приёмки:
    - `docker compose up -d --build` поднимает PostgreSQL, PgAdmin, HTTP Service, TG Bot, AI Service, Ollama.
    - Makefile предоставляет цели `up`, `down`, `logs`, `restart`, `ngrok-up`, `ngrok-url`.

- User Story: Как владелец внешней админки, я хочу запускать PHP‑админку отдельно.
  - Критерии приёмки:
    - `adm_web` запускается отдельной командой; соединяется с `adm_pg` (внешний том `adm_pg_data`).

### Эпик 6: Безопасность и конфигурация

- User Story: Как DevOps, я хочу хранить секреты в окружении, а не в коде.
  - Критерии приёмки:
    - Токен бота `TG_BOT_TOKEN` берётся из переменных окружения.
    - БД‑строки `DATABASE_URL`, `TG_BOT_DATABASE_URL`, `AI_DATABASE_URL` не захардкожены в коде.

- User Story: Как ответственный за репозиторий, я не хочу, чтобы секреты попадали в Git‑историю.
  - Критерии приёмки:
    - При обнаружении секретов включается Push Protection; история переписывается, чувствительные данные скрываются.

### Эпик 7: Тестирование и качество

- User Story: Как разработчик, я хочу иметь интеграционный тест БД бота.
  - Критерии приёмки:
    - Фикстура создаёт временную БД, применяет схему, выполняет CRUD и удаляет БД.
    - Тест проверяет приветствие, сохранение входящих/исходящих сообщений, профиль пользователя.

- User Story (выровнять код и тесты): как разработчик, я хочу, чтобы тесты HTTP‑сервиса соответствовали актуальным эндпоинтам.
  - Критерии приёмки:
    - Либо реализован `GET /users/{id}` и `GET /proxy`, либо тесты обновлены под текущие роуты (`/ping`, `/tg/messages`).

- User Story: Как разработчик, я хочу автоматический прогон тестов локально и в CI.
  - Критерии приёмки:
    - pre-commit запускает `pytest` (быстрый прогон);
    - GitHub Actions (`ci.yml`) прогоняет тесты на каждый push/PR.

## Use Case (по функциональным областям)

1. Приветствие нового пользователя
   - Акторы: Пользователь TG, TG Bot
   - Поток: `/start` → чтение `bot_settings.greeting_text` → отправка сообщения → `user_state.greeted_at` → запись в `outgoing_message`.
   - Альтернатива: первое обычное сообщение без `/start`.

2. Сохранение входящего сообщения
   - Акторы: Пользователь TG, TG Bot
   - Поток: получение `Message` → `user_profile` upsert → `incoming_message` insert.

3. Отправка события в HTTP‑сервис
   - Акторы: TG Bot, HTTP Service
   - Поток: `POST /tg/messages` с `message.model_dump()` → HTTP Service отвечает `{ok:true}` → аудит запроса/ответа в своей БД.
   - Замечание: HTTP Service не сохраняет доменные TG‑данные.

4. Генерация AI‑ответа
   - Акторы: TG Bot, AI Service, Ollama
   - Поток: `POST /generate` → `ai_session` ensure → запись `ai_message(user)` → вызов Ollama → запись `ai_message(assistant)` → возврат ответа боту.

5. Ответ через интент (FAQ)
   - Акторы: Пользователь TG, TG Bot
   - Поток: входящий текст → поиск в `intent` по приоритету и типу совпадения → если найден, ответ из `answer_text` → запись в `outgoing_message`.

6. Команды меню
   - Акторы: Пользователь TG, TG Bot
   - Поток: `/about` или `/cost` → внутренняя подстановка строк `about`/`cost` → поиск интента → ответ из БД.

7. Голосовые сообщения (текущее поведение)
   - Акторы: Пользователь TG, TG Bot
   - Поток: при наличии `voice` бот отвечает подсказкой "Пока не умею распознавать голосовые. Пришлите текст." → запись исходящего сообщения.

5. Аудит HTTP‑запросов
   - Акторы: Клиенты, HTTP Service
   - Поток: Middleware формирует `request_log` и `request_audit`, сохраняет длительность, заголовки, тело ответа при ошибках.

## Техническое описание для разработчика

- Контракты API:
  - HTTP Service: `GET /ping` → `{status:"ok"}`; `POST /tg/messages` → `{ok:true}` (универсальный приём событий).
  - AI Service: `POST /generate` → `{reply: string}`. Поддерживает поле `system`.
- Переменные окружения:
  - HTTP: `HTTP_SERVICE_LOG_LEVEL`, `DATABASE_URL`.
  - TG Bot: `TG_BOT_TOKEN`, `HTTP_SERVICE_BASE_URL`, `TG_BOT_DATABASE_URL`.
  - AI: `AI_DATABASE_URL`, `AI_MODEL`, `OLLAMA_BASE_URL`, `AI_REPLY_PREFIX` (fallback префикс).
- Временные лимиты: бот → AI до 60с, AI → Ollama до 120с.
- Схемы БД задокументированы в соответствующих сервисах; индексация на полях времени и связях.
- Наблюдаемость: логирование через middleware; аудит хранится в Postgres.

## Дорожная карта (Roadmap)

Короткий горизонт (1–2 спринта):
- Выровнять тесты HTTP‑сервиса и код: добавить `GET /users/{id}` и `GET /proxy` или обновить тесты под актуальные роуты.
- Покрыть AI Service и TG Bot базовыми юнит‑тестами (моки httpx/aiogram).
 - Вынести конфиги в `.env` и обновить `docker-compose.yml` для чтения `.env`.
 - Добавить STT‑сервис (например, `faster-whisper`) и транскрибирование голосовых в текст с сохранением транскрипта в БД бота.

Средний горизонт (3–4 спринта):
- Расширить аудит: masked‑поля, лимит хранения, retention‑политика.
- Добавить метрики Prometheus/Grafana.
- Ввести очереди (например, Redis) для декуплинга TG → HTTP при всплесках.
 - Добавить оповещения в Grafana/Loki по ключевым ошибкам (ReadTimeout, TelegramNetworkError, ollama 5xx).

Дальний горизонт:
- Поддержка дополнительных каналов (VK, WhatsApp) с сохранением принципа универсального HTTP‑сервиса.
- Модернизация AI (chain‑of‑thought, сохранение контекстов, выбор моделей).
 - CRUD‑управление интентами из админки/команд бота.

## План задач (Backlog по эпикам)

- Эпик 1 (HTTP):
  - [ ] Реализовать или скорректировать `/users/{id}`, `/proxy` и аудит для прокси, либо обновить тесты.
  - [ ] Документация OpenAPI для текущих эндпоинтов.

- Эпик 2 (TG Bot):
  - [ ] Команда смены приветствия (кнопка «Сменить приветствие» → запись в `bot_settings`).
  - [ ] Команда статуса (`/status`) с краткой диагностикой.

- Эпик 3 (AI):
  - [ ] Конфигурируемая модель (`AI_MODEL`) и обработка недоступности Ollama с ретраями.

- Эпик 4 (Наблюдаемость):
  - [ ] Структурированные логи (structlog) во всех сервисах, кореляция по `request_id`.

- Эпик 5 (Инфраструктура):
  - [ ] Опциональный `profiles:` в docker‑compose для выборочного подъёма сервисов.
  - [ ] Предустановленные подключения PgAdmin к БД `tg_bot` и `ai_service`.

- Эпик 6 (Безопасность):
  - [ ] Хранение секретов в `.env`/secret manager, убрать значения по умолчанию.

- Эпик 7 (Качество):
  - [ ] Покрытие тестами middleware аудита, фикстуры БД.
  - [ ] CI: Lint, Test, Build образы, публикация артефактов.


